# main.py
import sys
import os
from openai import OpenAI

from prompt import SYSTEM_PROMPT, build_user_prompt
from parser import (
    parse_alert_text,
    build_filename,
    ensure_splunk_sid,
    build_front_matter,
    build_scoring_block,
    compute_triage_scores,
    parse_report_filename,
    read_front_matter,
    summarize_drivers,
    classify_tier,
    format_tier,
)
import csv

def read_input() -> str:
    """
    stdin または ファイル引数からアラートテキストを取得
    - Linux: python main.py < alert.txt
    - PowerShell: Get-Content alert.txt -Encoding UTF8 | python main.py
    - 共通: python main.py alert.txt
    """
    if len(sys.argv) > 1:
        with open(sys.argv[1], "r", encoding="utf-8") as f:
            return f.read()
    return sys.stdin.read()


def generate_index_md(output_dir: str = "output") -> str:
    """
    output/ 配下のレポートを走査して index.md を再生成する。
    - ファイル名から time/alert/host/category を復元
    - front matter から sid/suspicion/confidence を取得
    """
    os.makedirs(output_dir, exist_ok=True)

    files = [
        f for f in os.listdir(output_dir)
        if f.lower().endswith(".md") and f.lower() != "index.md"
    ]

    # 最新が上に来るように、ファイル名先頭のtimestampで降順ソート
    def sort_key(name: str) -> str:
        return name.split("_")[0] if "_" in name else name

    files.sort(key=sort_key, reverse=True)

    rows = []
    for f in files:
        base = parse_report_filename(f)
        meta = read_front_matter(os.path.join(output_dir, f))

        base["sid"] = meta.get("splunk_sid", "Unknown")
        base["suspicion"] = meta.get("suspicion", "Unknown")
        base["confidence"] = meta.get("confidence", "Unknown")

        base["drivers"] = meta.get("drivers_short", "")

        susp = int(base["suspicion"]) if str(base["suspicion"]).isdigit() else 0
        raw_tier = classify_tier(susp)

        base["tier"] = raw_tier                 # CSV・内部用
        base["tier_display"] = format_tier(raw_tier)  # MD表示用

        rows.append(base)

    lines = []
    lines.append("# Incident Reports Index\n\n")
    lines.append("Generated by incident_ai.\n\n")
    lines.append("| time | alert | host | category | tier | sid | suspicion | confidence | file |\n")
    lines.append("|---|---|---|---|---|---|---:|---:|---|\n")


    for r in rows:
        link = f"[{r['file']}]({r['file']})"
        lines.append(
            f"| {r['time']} | {r['alert']} | {r['host']} | {r['category']} | "
            f"{r['tier_display']} | {r['sid']} | {r['suspicion']} | {r['confidence']} | {link} |\n"
        )

    index_path = os.path.join(output_dir, "index.md")
    with open(index_path, "w", encoding="utf-8") as f:
        f.write("".join(lines))

    csv_path = os.path.join(output_dir, "index.csv")
    with open(csv_path, "w", newline="", encoding="utf-8") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow([
            "time", "alert", "host", "category",
            "sid", "tier", "suspicion", "confidence", "drivers", "file"
        ])
        for r in rows:
            writer.writerow([
                r["time"], r["alert"], r["host"], r["category"],
                r.get("sid"), r.get("tier"),          # ← raw tier
                r.get("suspicion"), r.get("confidence"),
                r.get("drivers"), r["file"]
            ])

    return index_path

def main():
    alert_text = read_input()

    if not alert_text.strip():
        print("No alert input provided.")
        return

    # 1) Parse & normalize fields
    fields = parse_alert_text(alert_text)
    fields = ensure_splunk_sid(fields)

    # 2) Rule-based scoring (NO final decision)
    scores = compute_triage_scores(fields)

    # 3) Build prompts
    user_prompt = build_user_prompt(fields)

    # 4) Call LLM (writing only)
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    model = os.getenv("INCIDENT_AI_MODEL", "gpt-4o-mini")
    temperature = float(os.getenv("INCIDENT_AI_TEMPERATURE", "0.2"))
    response = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": user_prompt},
        ],
        temperature=temperature,
    )
    report = response.choices[0].message.content

    # 5) Build report header blocks
    front_matter = build_front_matter(fields, scores)
    scoring_block = build_scoring_block(scores)

    # 6) Save report
    filename = build_filename(fields)
    output_dir = "output"
    os.makedirs(output_dir, exist_ok=True)

    output_path = os.path.join(output_dir, filename)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(front_matter)
        f.write(scoring_block)
        f.write(report)

    # 7) Update index
    index_path = generate_index_md(output_dir)

    print(f"Incident report generated: {output_path}")
    print(f"Index updated: {index_path}")


if __name__ == "__main__":
    main()
